'use strict';

import * as _ from 'lodash';
import { Singleton, AutoWired, Inject } from 'typescript-ioc';
import { Database } from '../database';
import { ConfigPackageService } from '../service/config-package';
import chalk from 'chalk';
import { GatewayConfig } from '../config/gateway';
import { ApiConfig } from '../config/api';
const compareVersions = require('compare-versions');

@Singleton
@AutoWired
export class VersionUpgrades {
    @Inject private database: Database;
    @Inject private service: ConfigPackageService;

    async checkGatewayVersion(): Promise<void> {
        const packageJson = require('../../package.json');
        const version = await this.database.getGatewayVersion();
        const compared = compareVersions(packageJson.version, version || '0.0.1');
        if ( compared === 0) {
            return;
        } else if (compared < 0) {
            throw new Error('Can not load configuration. This configuration repository contains information generated by a newer tree-gateway version. Try to update tree-gateway, running npm i -g tree-gateway.');
        }
        await this.updateGatewayConfiguration();
    }

    private async updateGatewayConfiguration() {
        const previous = await this.database.startGatewayUpdate();
        if (previous !== Database.UPDATING) {
            await this.update(previous);
        } else {
            await this.wait(0);
        }
    }

    private async update(version: string) {
        if (compareVersions(version || '0.0.1', '3.0.0') < 0) {
            const pac = await this.service.get();
            if (pac && pac.gateway) {
                console.info(chalk.magenta('An older configuration was found. Updating it to the newer format. '
                                                + 'Check tree-gateway migration guide for more info.'));
                pac.gateway = <GatewayConfig>_.omit(pac.gateway, 'statsConfig', 'monitor');
            }
            if (pac.apis) {
                pac.apis = pac.apis.map(api => {
                    if (_.has(api, 'proxy.disableStats')) {
                        api.disableStats = _.get(api.proxy, 'disableStats');
                    }
                    if (_.has(api, 'proxy.parseReqBody')) {
                        api.parseReqBody = _.get(api.proxy, 'parseReqBody');
                    }
                    if (_.has(api, 'proxy.parseCookies')) {
                        api.parseCookies = _.get(api.proxy, 'parseCookies');
                    }
                    if (_.has(api, 'proxy.interceptor')) {
                        api.interceptor = _.get(api.proxy, 'interceptor');
                    }
                    return <ApiConfig>_.omit(api, 'proxy.statsConfig', 'proxy.disableStats',
                                            'proxy.parseReqBody', 'proxy.parseCookies',
                                            'proxy.interceptor');
                });
            }
            await this.service.set(pac);
            await this.database.registerGatewayVersion();
        }
    }

    private wait(count: number) {
        return new Promise<void>((resolve, reject) => {
            if (count > 10) {
                return reject(new Error('Can not upgrade gateway configuration.'));
            }
            setTimeout(() => {
                this.database.getGatewayVersion()
                    .then(version => {
                        if (version === Database.UPDATING) {
                            this.wait(count++)
                                .then(resolve)
                                .catch(reject);
                        } else {
                            resolve();
                        }
                    });
            }, 100);
        });
    }
}
