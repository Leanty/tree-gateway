{"version":3,"sources":["../../src/lib/config.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC","file":"config.js","sourcesContent":["\"use strict\";\n\n/**\n * The API config descriptor.\n */\nexport interface Api {\n    /**\n     * The API name. Used to identify the API on admin console. \n     */\n    name: string;\n    /**\n     * The API version. More than one version can be published for the same API.\n     */\n    version: string;\n    /**\n     * Configuration for the API proxy engine.\n     */\n    proxy: Proxy;\n    /**\n     * Configuration for the rate limit engine.\n     */\n    throttling?: Throttling;\n\n    /**\n     * Configuration for API authentication.\n     */\n    authentication?: Authentication;\n\n    serviceDiscovery?: ServiceDiscovery;\n}\n\n/**\n * Configuration for the API proxy engine.\n */\nexport interface Proxy {\n    /**\n     * The path where the gateway will listen for requests that should be proxied\n     * for the current API.\n     */\n    path: string;\n    /**\n     * The target address of the proxied API. You can force the protocol to be \n     * used on the URL, as:\n     * ```\n     * \"target\": {\n     *      \"path\": \"http://httpbin.org\",\n     *  }\n     * \n     * ```\n     * \n     * Or you can leave the decision for the gateway:\n     * \n     * \"target\": {\n     *      \"path\": \"httpbin.org\",\n     *  }\n     * \n     * So the gateway will use the same protocol used to access the gateway for the \n     * request to the target.\n     * \n     * If you want to force https for the target API request, use the https option.  \n     */\n    target: Target;\n    /**\n     * If set to true, will enforce the requests to the API target to use HTTPS protocol.\n     * f your path already define a protocol on target URL, this option is ignored.\n     */\n    https?: boolean\n    /**\n     * Add filters to the request pipeline. A Filter is a function that receives\n     * the request and the response object and must return a boolean value to inform\n     * it the given request should target the destination API or if it should be ignored.\n     * \n     * Example:\n     * ```\n     * module.exports = function (req, res) {\n     *   return true;\n     * };\n     * ```\n     * \n     * Each filter must be defined on its own .js file (placed on middleware/filter folder)\n     * and the fileName must match: <filterName>.js. \n     * \n     * So, the above filter should be saved in a file called myFilter.js and configured as:\n     * ```\n     * filter:[\n     *   {name: \"myFilter\"}\n     * ]\n     * ``` \n     */\n    filter?: Array<Filter>,\n    /**\n     * Add interceptors to the request pipeline. An Interceptor is a function that receives\n     * the request or the response object and can modify these objects.\n     * \n     * You can define two types of interceptors: Request Interceptors or Response Interceptors.\n     * \n     * Example of a request interceptor:\n     * ```\n     * module.exports = function(proxyReq, originalReq) {\n     *    // you can update headers \n     *    proxyReq.headers['Content-Type'] = 'text/html';\n     *    // you can change the method \n     *    proxyReq.method = 'GET';\n     *    // you can munge the bodyContent. \n     *    proxyReq.bodyContent = proxyReq.bodyContent.replace(/losing/, 'winning!');\n     *    return proxyReq;\n     * };\n     * ```\n     * \n     * Example of a response interceptor:\n     * ```\n     * module.exports = function(rsp, data, req, res, callback) {\n     *    // rsp - original response from the target \n     *    data = JSON.parse(data.toString('utf8'));\n     *    callback(null, JSON.stringify(data));\n     *    // callback follow the node conventions ```callback(error, value)```\n     * };\n     * ```\n     * \n     * Each interceptor must be defined on its own .js file (placed on middleware/interceptor/[request | response] folder)\n     * and the fileName must match: <interceptorName>.js. \n     * \n     * So, the above request interceptor should be saved in a file called \n     * middleware/interceptor/request/myRequestInterceptor.js and configured as:\n     * \n     * ```\n     * interceptor:{\n     *    request: [\"myRequestInterceptor\"]\n     * }\n     * ```\n     * \n     * If more than one request or response interceptor are defined, they are executed in declaration order. \n     */\n    interceptor?: Interceptors,\n    preserveHostHdr?: boolean;\n    timeout?: number;\n}\n\nexport interface ServiceDiscovery {\n}\n/**\n * Add filters to the request pipeline. A Filter is a function that receives\n * the request and the response object and must return a boolean value to inform\n * it the given request should target the destination API or if it should be ignored.\n */\nexport interface Filter {\n    /**\n     * The filter name.\n     */\n    name: string,\n    /**\n     * A list of paths that should be filtered by this filter. If not provided, all paths\n     * will be filtered.\n     * Defaults to *.\n     */\n    appliesTo?: Array<string>;\n}\n\n/**\n * Add interceptors to the request pipeline. An Interceptor is a function that receives\n * the request or the response object and can modify these objects.\n */\nexport interface Interceptors {\n    /**\n     * A list of request interceptors\n     */\n    request: Array<Interceptor>;\n    /**\n     * A list of response interceptors\n     */\n    response: Array<Interceptor>;\n}\n\n/**\n * An Interceptor is a function that receives\n * the request or the response object and can modify these objects.\n */\nexport interface Interceptor {\n    /**\n     * The interceptor name.\n     */\n    name: string,\n    /**\n     * A list of paths that should be intercepted by this interceptor. If not provided, all paths\n     * will be intercepted.\n     * Defaults to *.\n     */\n    appliesTo?: Array<string>;\n}\n\nexport interface Target {\n    path: string;\n    allowPath?: Array<string>;\n    denyPath?: Array<string>;\n    allowMethod?: Array<string>;\n    denyMethod?: Array<string>;\n}\n\nexport interface Throttling {\n    /**\n     * milliseconds - how long to keep records of requests in memory. \n     * Defaults to 60000 (1 minute).  \n     */\n    windowMs?: number;\n    /**\n     * max number of connections during windowMs before starting to delay responses. \n     * Defaults to 1. Set to 0 to disable delaying.\n     */\n    delayAfter?: number;\n    /**\n     * milliseconds - how long to delay the response, multiplied by (number of recent hits - delayAfter). \n     * Defaults to 1000 (1 second). Set to 0 to disable delaying.\n     */\n    delayMs?: number;\n    /**\n     * max number of connections during windowMs milliseconds before sending a 429 response. \n     * Defaults to 5. Set to 0 to disable.\n     */\n    max?: number;\n    /**\n     * Error message returned when max is exceeded. \n     * Defaults to 'Too many requests, please try again later.'\n     */\n    message?: string;\n    /**\n     * HTTP status code returned when max is exceeded. \n     * Defaults to 429.\n     */\n    statusCode?: number;\n    /**\n     * Enable header to show request limit and current usage.\n     */\n    headers?: boolean;\n    /**\n     * The name of the function used to generate keys. By default user IP address (req.ip) is used.\n     * For Example, on myKeyGen.js file:\n     * ```\n     * module.exports = function (req) {\n     *    return req.ip;\n     * };\n     * ```\n     * This function must be saved on a js file:\n     * ``` \n     * middleware/throttling/keyGenerator/myKeyGen.js\n     * ```\n     */\n    keyGenerator?: string;\n    /**\n     * The name of the function to execute once the max limit is exceeded. It receives the request \n     * and the response objects. The \"next\" param is available if you need to pass to the \n     * next middleware.\n     * \n     * For Example, on myHandler.js file:\n     * ```\n     * module.exports = function (req, res) {\n     *   res.format({\n     *      html: function(){\n     *         res.status(options.statusCode).end(options.message);\n     *      },\n     *      json: function(){\n     *         res.status(options.statusCode).json({ message: options.message });\n     *      }\n     *   });\n     * };\n     * ```\n     * This function must be saved on a js file:\n     * ``` \n     * middleware/throttling/handler/myHandler.js\n     * ```\n     */\n    handler?: string;\n    /**\n     * The storage to use when persisting rate limit attempts. \n     * By default, the MemoryStore is used. Possible values are: \n     * ```\n     * memory\n     * ```\n     * And\n     * ```\n     * redis\n     * ```\n     */\n    store?: string; \n}\n\nexport interface Authentication {\n    jwt?: JWTAuthentication;\n    basic?: BasicAuthentication;\n}\n\nexport interface BasicAuthentication {\n    /**\n     * Is a function with the parameters verify(userid, password, done) {\n     *  - userid The username.\n     *  - password The password.\n     *  - done is a passport error first callback accepting arguments done(error, user, info)\n     */    \n    verify: string;\n}\n\nexport interface JWTAuthentication {\n    /**\n     * Is a REQUIRED string or buffer containing the secret (symmetric) \n     * or PEM-encoded public key (asymmetric) for verifying the token's signature.\n     */\n    secretOrKey:string;\n    /**\n     * Defines how the JWT token will be extracted from request.\n     */\n    extractFrom?: JWTRequestExtractor; \n    /**\n     * If defined the token issuer (iss) will be verified against this value.\n     */\n    issuer?: string;\n    /**\n     * If defined, the token audience (aud) will be verified against this value.\n     */\n    audience?: string;\n    /**\n     * List of strings with the names of the allowed algorithms. For instance, [\"HS256\", \"HS384\"].\n     */\n    algorithms: Array<string>;\n    /**\n     * If true do not validate the expiration of the token.\n     */\n    ignoreExpiration?: boolean;\n    /**\n     * Is a function with the parameters verify(request, jwt_payload, done) \n     *  - request The user request.\n     *  - jwt_payload is an object literal containing the decoded JWT payload.\n     *  - done is a passport error first callback accepting arguments done(error, user, info)\n     */    \n    verify?: string;\n}\n\nexport interface JWTRequestExtractor {\n    header?: string;\n    queryParam?: string;\n    authHeader?: string;\n    bodyField?: string;\n    cookie?: string;\n}\n"]}