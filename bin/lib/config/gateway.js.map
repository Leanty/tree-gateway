{"version":3,"sources":["../../src/lib/config/gateway.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAwLb,WAAY,QAAQ;IAChB,yCAAK,CAAA;IAAE,uCAAI,CAAA;IAAE,yCAAK,CAAA;AACtB,CAAC,EAFW,gBAAQ,KAAR,gBAAQ,QAEnB;AAFD,IAAY,QAAQ,GAAR,gBAEX,CAAA","file":"gateway.js","sourcesContent":["\"use strict\";\n\n/**\n * The API config descriptor.\n */\nexport interface GatewayConfig {\n    /**\n     * The gateway port\n     */\n    listenPort: string;\n    /**\n     * The gateway admin server port\n     */\n    adminPort: string;\n    /**\n     * The root folder where the gateway will work.\n     */\n    rootPath: string;\n    /**\n     * Folder where the gateway will search for installed APIs.\n     */\n    apiPath: string;\n    /**\n     * Folder where the gateway will search for its middleware functions.\n     */\n    middlewarePath: string;\n    /**\n     * If we are behind a reverse proxy (Heroku, Bluemix, AWS if you use an ELB, custom Nginx setup, etc)\n     */\n    underProxy?: boolean;\n    /**\n     * Configurations for gateway logger.\n     */\n    logger?: LoggerConfig;\n    /**\n     * Configurations for gateway database (REDIS).\n     */\n    database?: RedisConfig;\n    /**\n     * Configurations for gateway logger.\n     */\n    accessLogger?: AccessLoggerConfig;\n\n}\n\nexport interface AccessLoggerConfig {\n\n}\n\nexport interface RedisConfig {\n    host: string;\n    port: number;\n}\n\nexport interface LoggerConfig {\n    /**\n     * Level of messages that this logger should log.\n     */\n    level?: string;\n    console?: LogConsoleConfig;\n    file?: LogFileConfig;\n}\n\nexport interface LogConsoleConfig {\n    /**\n     * flag indicating if we should prepend output with timestamps (default true). \n     */\n    timestamp?: boolean;\n    /**\n     * Flag indicating whether to suppress output.\n     */\n    silent?: boolean; \n    /**\n     * Flag indicating if we should colorize output.\n     */\n    colorize?: boolean; \n    /**\n     * If true, messages will be logged as JSON (default true).\n     */\n    json?: boolean;\n    /**\n     * Flag indiciating if the output should be passed through JSON.stringify, \n     * resulting in single-line output. Most useful when used in conjunction with \n     * the json flag. (default false)\n     */\n    stringify?: boolean; \n    /**\n     * If true, additional JSON metadata objects that are added to logging string \n     * messages will be displayed as a JSON string representation.  \n     */\n    prettyPrint?: boolean;\n    /**\n     * Numeric indicating how many times to recurse while formatting the object with util.inspect \n     * (only used with prettyPrint: true) \n     * (default null, unlimited)\n     */\n    depth?: number; \n    /**\n     * Flag indicating if uncaught exception should be output as human readable, instead of a single line\n     */\n    humanReadableUnhandledException?: boolean; \n    /**\n     * Flag indicating if we should prepend output with level (default true).\n     */\n    showLevel?: boolean;\n    /**\n     * Array of strings containing the levels to log to stderr instead of stdout, for example \n     * ['error', 'debug', 'info']. (default ['error', 'debug'])\n     */\n    stderrLevels?: Array<string>;     \n}\n\nexport interface LogFileConfig {\n    /**\n     * The filename of the logfile to write output to.\n     */\n    filename?: string;\n    /**\n     * flag indicating if we should prepend output with timestamps (default true). \n     */\n    timestamp?: boolean;\n    /**\n     * Flag indicating whether to suppress output.\n     */\n    silent?: boolean; \n    /**\n     * Flag indicating if we should colorize output.\n     */\n    colorize?: boolean; \n    /**\n     * Max size in bytes of the logfile, if the size is exceeded then a new file is created, \n     * a counter will become a suffix of the log file. \n     */\n    maxsize?: number; \n    /**\n     * Limit the number of files created when the size of the logfile is exceeded.\n     */\n    maxFiles?: number;\n    /**\n     * If true, messages will be logged as JSON (default true).\n     */\n    json?: boolean;\n    /**\n     * String indicating the end-of-line characters to use (default to \\n).\n     */\n    eol?: string;\n    /**\n     * If true, additional JSON metadata objects that are added to logging string \n     * messages will be displayed as a JSON string representation.  \n     */\n    prettyPrint?: boolean;\n    /**\n     * Numeric indicating how many times to recurse while formatting the object with util.inspect \n     * (only used with prettyPrint: true) \n     * (default null, unlimited)\n     */\n    depth?: number; \n    /**\n     * If true, messages will be logged as JSON and formatted for logstash (default false).\n     */\n    logstash?: boolean;\n    /**\n     * Flag indicating if we should prepend output with level (default true).\n     */\n    showLevel?: boolean;\n    /**\n     * If true, log files will be rolled based on maxsize and maxfiles, but in ascending order. \n     * The filename will always have the most recent log lines. The larger the appended number, \n     * the older the log file. \n     * This option requires maxFiles to be set, or it will be ignored.\n     */\n    tailable?: boolean;\n    /**\n     * The number of stream creation retry attempts before entering a failed state. \n     * In a failed state the transport stays active but performs a NOOP on it's log function. \n     * (default 2)\n     */\n    maxRetries?: number;\n    /**\n     * If true, all log files but the current one will be zipped.\n     */\n    zippedArchive?: boolean;\n}\n\nexport enum LogLevel {\n    error, info, debug\n}"]}